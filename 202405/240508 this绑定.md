# this绑定

[toc]

参考《你不知道的JavaScript(上卷)》P82

## 1、默认绑定

独立函数调用，绑定为全局window
用了严格模式的，this会绑定到undefined

```JavaScript
function foo () {
  "ues strict"
  console.log(this)
}
foo();
```

&nbsp;

## 2、隐式绑定

看调用位置是否有上下文（是否被某个对象拥有或包含），只有最后一层会影响
函数的嵌套调用不属于被对象包含，不影响this

```JavaScript
function foo() { 
 console.log( this.a );
}
var obj2 = { 
 a: 42,
 foo: foo 
};
var obj1 = { 
 a: 2,
 obj2: obj2 
};
obj1.obj2.foo(); // 42
```

### 隐式丢失

被隐式绑定的函数丢失绑定对象，此时应用默认绑定
参数传递、赋值、引用都会造成隐式丢失

```JavaScript
function foo() { 
 console.log( this.a );
}
var obj = { 
 a: 2,
 foo: foo 
};
var bar = obj.foo; // 函数别名！
var a = "oops, global"; // a 是全局对象的属性
bar(); // "oops, global"
```

虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的
bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。

```JavaScript
function foo() { 
 console.log( this.a );
}
function doFoo(fn) {
 var a = 1; // 干扰项，函数的嵌套调用不属于对象包含，不改变this
 // fn 其实引用的是 foo
 fn(); // <-- 调用位置！
}
var obj = { 
 a: 2,
 foo: foo 
};
var a = "oops, global"; // a 是全局对象的属性
doFoo( obj.foo ); // "oops, global"
```

把函数传入语言内置函数和自己声明的函数，结果一样

```JavaScript
function foo() { 
 console.log( this.a );
}
var obj = { 
 a: 2,
 foo: foo 
};
var a = "oops, global"; // a 是全局对象的属性
setTimeout( obj.foo, 100 ); // "oops, global"
```

&nbsp;

## 3、显式绑定

隐式绑定中，需要将函数包含在一个对象内调用，才能将this隐式绑定在这个对象上。如果不想在对象内包含这个函数的引用，而又要在对象上强制调用函数，则可以用显示绑定，通过call(...)和apply(...)指定要绑定到this的对象

call(...)和apply(...)第一个参数通常为对象，如果传的是原始值（字符串、布尔、数字），则会自动转换为对象形式(new String(...) 或 new Object(...) 或 Object(...))，这个操作称为“装箱”

隐式绑定，在引用、赋值、传递时会造成绑定丢失问题，可以用显示绑定的变种“硬绑定”来解决

### 1）硬绑定（bind函数）

原理：执行目标函数前，创建一个包裹函数，其内部调用显示绑定过的目标函数。之后无论如何调用包裹函数，都不用担心目标函数的this丢失。ES5提供了内置方法实现该功能 Function.prototype.bind

```JavaScript
function foo () {
  console.log(this.a)
}
var a = 1
var obj = { 
  a: 2,
  foo
}
obj.foo() // 2
setTimeout(obj.foo, 100) // 1 隐式绑定丢失
setTimeout('obj.foo()', 100) // 2
obj.foo.call(window) // 1 显示绑定到别的对象
obj.foo.call(obj) // 2
```

**硬绑定改造**：

```JavaScript
function foo () {
  console.log(this.a)
}
var a = 1
var obj = { a: 2 }
var myBind = function () {
  foo.call(obj)
}
myBind() // 2
setTimeout(myBind, 100) // 2
myBind.call(window) // 2 硬绑定后如何调用包裹函数都不会改动目标函数的this
```

**在外包裹一层函数可以增加参数透传功能**：

```JavaScript
function foo (something) {
  console.log(this.a, something)
}
var myBind = function () {
  return foo.apply(obj, arguments)
}
// 或
var myBind = function () {
  return foo.call(obj, ...arguments)
}
```

硬绑定解决了this丢失问题，但无法二次更改绑定对象
可以创建一个**辅助绑定函数（bind）**，只需在透传包裹函数外再包裹一个函数，指定**目标函数**和**this对象**即可

```JavaScript
var myBind = function (fn, obj) {
  return function () {
    return fn.apply(obj, arguments)
  }
}
```

ES5提供了Function.prototype.bind方法，用法如下：

```JavaScript
function foo(something) {
  console.log(this.a, something)
  return this.a + something
}
var a = 1
var obj = { a: 2 }
var bar = foo.bind(obj)
var b = bar(3) // 2 3
console.log(b) // 5
```

&nbsp;

### 2）API调用上下文

第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一
个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调
函数使用指定的 this。

```JavaScript
function foo(el) {
  console.log(el, this.id)
}
var id = 'interfere'
var obj = { id: 'result' }
[1, 2, 3].forEach(foo, obj) // 1 result 2 result 3 result
```

调用foo时时通过call(...)或apply(...)进行显示绑定，将obj绑定为this

&nbsp;

## 4、new绑定

在传统的面向类的语言中，“构造函数”是类中的特殊方法，使用new初始化类时会调用类中的构造函数。

虽然在ES6中引入了class语法糖，但JavaScript本质还是基于原型的继承的，类的本质还是函数，而new的操作就是调用这些函数创建一个对象。

使用new来调用一个函数时会发生：

1. 创建（构造）一个全新的对象
2. 将新对象进行原型链接
3. 将新对象绑定到函数调用中的this
4. 如果函数没有返回其他对象（无返回或返回为基本数据类型），那么new表达式中的函数会自动返回这个新对象；如果返回的是个对象，则会抛弃原先创建的对象

```JavaScript
function foo(a) {
  this.a = a
}
function foo1(a) {
  this.a = a
  return 2
}
function foo2(a) {
  this.a = a
  return { b: a }
}
var bar = new foo(2)
var bar1 = new foo1(2)
var bar2 = new foo2(2)
console.log(bar) // { a: 2 }
console.log(bar1) // { a: 2 }
console.log(bar2) // { b: 2 }
```

`bar.__proto__.constructor`和`bar1.__proto__.constructor`分别 `foo`和`foo1`
`bar2.__proto__.constructor`是`Object`

使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定
&nbsp;

## 5、优先级

**this绑定一共有四条规则**：**默认绑定**、**隐式绑定**、**显示绑定**、**new绑定**

**默认绑定是优先级最低的**。

隐式绑定和显示绑定优先级的比较：

```JavaScript
function foo() {
  console.log(this.a)
}
var obj1 = {
  a: 1,
  foo
}
var obj2 = {
  a: 2,
  foo
}
obj1.foo() // 1
obj2.foo() // 2
obj1.foo.call(obj2) // 2
obj2.foo.call(obj1) // 1
```

**显示绑定比隐式绑定的优先级更高**。

隐式绑定和new绑定优先级的比较：

```JavaScript
function foo() {
  console.log(this.a)
}
var obj1 = {
  a: 1
  foo
}
var newObj = new obj1.foo()
console.log(newObj.a) // undefined
console.log(obj1.a) // 1
```

**new绑定比隐式绑定的优先级更高**。

new绑定和显示绑定优先级的比较：

```JavaScript
function foo(something) {
  this.a = something
}
var obj1 = {}
var bar = foo.bind(obj1)
bar(2)
console.log(obj1.a) // 2
var baz = new bar(3)
console.log(obj1.a) // 2
console.log(baz.a) // 3
```

**bind中存在方法用于判断是否被new调用，是的话则使用新创建的this替换硬绑定的this**。

由此可得this优先级：**new绑定 > 显示绑定 > 隐式绑定 > 默认绑定**

为什么要在new中使用硬绑定函数，而不直接使用简单的普通函数？
硬绑定bind(...)除了指定this外，还有一个功能，就是传参给下层参数。因此，如果要预设函数的一些参数时，就可能用到new中使用硬绑定函数。

该技术被称为“部分应用”，是“柯里化”的一种：

```JavaScript
function foo(p1, p2) {
  this.val = p1 + p2
}
var bar = foo.bind(null, 1)
// 因为在该场景中，new一个硬绑定函数化的构造函数，新this会取代原先硬绑定的this，所以bind的第一个参数传什么都无所谓，可直接传null
var baz = new bar(2)
baz.val // 3
```

### 判断this优先级的顺序

1. 函数是否在 new 中调用（new 绑定）？如果是的话this 绑定的是新创建的对象。
`var bar = new foo()`
2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。
`var bar = foo.call(obj2)`
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。
`var bar = obj1.foo()`
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。
`var bar = foo()`

&nbsp;

## 6、绑定例外

在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用的可能是默认绑定规则

### 1）被忽略的this

### 2）间距引用

### 3）软绑定
