# this、作用域、闭包

[toc]

## 1、JS函数生成器，function* () {}

<https://www.cnblogs.com/yuzhengbo/p/6807914.html>

&nbsp;

## 2、ES6中新增加的Symbol数据类型及其使用场景

<https://blog.csdn.net/JHXL_/article/details/132844454>
&nbsp;

## 3、手写call、apply

call() 方法用于指定一个this值，和单独给出一个或多个参数来调用一个函数
和apply() 类似，区别在于call() 方法接受一个参数列表，apply() 方法接受一个包含多个参数的数组
手写参考：<https://www.jb51.net/javascript/284715v74.htm>

```JavaScript
function.call(thisArg, arg1, arg2, ...)
function.apply(thisArg, argsArray)
```

```JavaScript
Function.prototype.myCall = function (context, ...params) {
  context == null ? context = window : null
  !/^(object|function)$/.test(typeof context) ? context = Object(context) : null
  _this = this, result = null, key = Symbol('FUNC_KEY')
  context[key] = _this
  result = context[key](...params)
  delete context[key]
  return result
}
```

原理：context是数据对象，Function中的this是函数本身，往数据对象中添加一个函数，执行后删除函数，返回执行结果
注意：
1、判断context是否有传，未传则为window
2、判断context是不是引用数据类型，不是则转换为引用数据类型
3、保留this指向，创建Symbol key保证不冲突
4、把函数放到context中执行（改变了函数执行时的this指向），记录结果，删除函数
5、执行时通过context.key()执行，此时函数的this会指向context
&nbsp;

```JavaScript
Function.prototype.myApply = function (context, params = []) {
  context = context || window
  !/^(object|function)$/.test(typeof context) ? context = Object(context) : null
  _this = this, result = null, key = Symbol('func_key')
  context[key] = _this
  result = context[key](...params)
  delete context[key]
  return result
}
```

与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的则会）。
所以this为null时默认绑定时，var变量可被访问，let变量不可

## 4、arguments

常用于中间函数的参数透传，或多种参数数量情况的函数
1.arguments对象和Function是分不开的。
2.因为arguments这个对象不能显式创建。
3.arguments对象只有函数开始时才可用。
arguments是类数组，不是数组
用法：
arguments.length 长度
arguments.callee(...) 调用函数自身（递归）

```JavaScript
function sum (n) {
  if (n <= 1) { return n }
  else {
    return n + arguments.callee(n - 1)
  }
}
console.log(sum(6)) // 21
```

注意agruments传递参数为函数时，this的指向问题：

```JavaScript
var length = 10;
function fn() {
  console.log(this.length);
}
var obj = {
  method: function(fn) {
    fn();
    arguments[0]();
  },
  length: 5
};
obj.method(fn, 1);
```

fn参数为引用数据类型，调用时逐层溯源查看是否有上下文关系，无所以采用this的默认绑定，绑定为全局window
arguments[0]值为fn，由于arguments[0]挂在arguments下，存在上下文关系（对象包含关系），所以采用this的隐式绑定，绑定为arguments

输出：

```Output
10
2
```

&nbsp;

## 5、this绑定

参考《你不知道的JavaScript(上卷)》P82

### 1)默认绑定

独立函数调用，绑定为全局window
用了严格模式的，this会绑定到undefined

```JavaScript
function foo () {
  "ues strict"
  console.log(this)
}
foo();
```

### 2)隐式绑定

看调用位置是否有上下文（是否被某个对象拥有或包含），只有最后一层会影响
函数的嵌套调用不属于被对象包含，不影响this

```JavaScript
function foo() { 
 console.log( this.a );
}
var obj2 = { 
 a: 42,
 foo: foo 
};
var obj1 = { 
 a: 2,
 obj2: obj2 
};
obj1.obj2.foo(); // 42
```

#### 隐式丢失
被隐式绑定的函数丢失绑定对象，此时应用默认绑定
参数传递、赋值、引用都会造成隐式丢失

```JavaScript
function foo() { 
 console.log( this.a );
}
var obj = { 
 a: 2,
 foo: foo 
};
var bar = obj.foo; // 函数别名！
var a = "oops, global"; // a 是全局对象的属性
bar(); // "oops, global"
```

虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的
bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。

```JavaScript
function foo() { 
 console.log( this.a );
}
function doFoo(fn) {
 var a = 1; // 干扰项，函数的嵌套调用不属于对象包含，不改变this
 // fn 其实引用的是 foo
 fn(); // <-- 调用位置！
}
var obj = { 
 a: 2,
 foo: foo 
};
var a = "oops, global"; // a 是全局对象的属性
doFoo( obj.foo ); // "oops, global"
```

把函数传入语言内置函数和自己声明的函数，结果一样

```JavaScript
function foo() { 
 console.log( this.a );
}
var obj = { 
 a: 2,
 foo: foo 
};
var a = "oops, global"; // a 是全局对象的属性
setTimeout( obj.foo, 100 ); // "oops, global"
```

### 3)显式绑定

隐式绑定中，需要将函数包含在一个对象内调用，才能将this隐式绑定在这个对象上。如果不想在对象内包含这个函数的引用，而又要在对象上强制调用函数，则可以用显示绑定，通过call(...)和apply(...)指定要绑定到this的对象

call(...)和apply(...)第一个参数通常为对象，如果传的是原始值（字符串、布尔、数字），则会自动转换为对象形式(new String(...) 或 new Object(...) 或 Object(...))，这个操作称为“装箱”

隐式绑定，在引用、赋值、传递时会造成绑定丢失问题，可以用显示绑定的变种“硬绑定”来解决

#### 硬绑定

原理：执行目标函数前，创建一个包裹函数，其内部调用显示绑定过的目标函数。之后无论如何调用包裹函数，都不用担心目标函数的this丢失

```JavaScript
function foo () {
  console.log(this.a)
}
var a = 1
var obj = { 
  a: 2,
  foo
}
obj.foo() // 2
setTimeout(obj.foo, 100) // 1 隐式绑定丢失
setTimeout('obj.foo()', 100) // 2
obj.foo.call(window) // 1 显示绑定到别的对象
obj.foo.call(obj) // 2
```

硬绑定改造

```JavaScript
function foo () {
  console.log(this.a)
}
var a = 1
var obj = { a: 2 }
var mid = function () {
  foo.call(obj)
}
mid() // 2
setTimeout(mid, 100) // 2
mid.call(window) // 2 硬绑定后如何调用包裹函数都不会改动目标函数的this
```

包裹函数可以增加参数透传功能

```JavaScript
function foo (something) {
  console.log(this.a, something)
}
var mid = function () {
  return foo.apply(obj, arguments)
}
// 或
var mid = function () {
  return foo.call(obj, ...arguments)
}
```

硬绑定解决了this丢失问题，但无法二次更改绑定对象
可以创建一个辅助绑定函数，只需在透传包裹函数外再嵌套一个函数，指定目标函数和this对象即可

```JavaScript
var mid = function (fn, obj) {
  return function () {
    return fn.apply(obj, arguments)
  }
}
```

## 6、原型、原型链

（是什么、怎么实现的、解决了什么问题、优点、缺点、如何改进缺点）

### 原型的概念

- 是什么：每一个类（构造函数）都有一个对象prototype，这被称为显示原型。每一个实例也有一个对象__proto__，被称为隐式原型。
- 怎么实现的：原型的本质就是一个挂载在构造函数或普通实例下的对象，包含了共享的属性和方法，并可以被其它对象继承使用。
- 解决了什么问题：对象可以通过原型链的方式，访问其原型的对象和方法，也可以访问其原型从其它原型那继承的对象和方法。
- 优点：
  - 可以共享属性和方法，节省内存提高性能；
  - 简化对象的创建，对于相似的对象可以轻松创建，只需修改部分属性即可；
  - 方便扩展，可以通过修改原型对象来新增方法和属性，从而对已有对象的功能进行扩展；
  - 动态性，由于JavaScript中的原型链是动态的，可以在运行时动态修改原型对象，所有该原型创建的对象都会受影响实时做出相应的更新。
- 缺点：
  - 属性共享可能导致意外的修改，影响原型关联的所有对象；
  - 无法针对不同对象传递不同参数，在创建对象时，构造函数可以根据场景传递不同的参数，但原型是所有相关对象共享的，无法传递不同参数；
  - 属性和方法会被共享暴露，如果对象需要自己私有的属性和方法，则不适合将属性和方法定义在原型上，因为会被所有对象共享
- 缺点如何改进：如果要完全避免属性共享造成的影响，不共享属性和方法，可以使用“工厂模式”创建对象

### 原型链的概念

- 是什么：原型链是JavaScript中对象的一种链接关系，每个对象都有链接着一个原型，而原型同样也是个对象，链接着原型的原型，最终形成一条链，也就是原型链
- 怎么实现的：原型链是通过原型的继承实现的，根据原型创建一个对象时，新对象会自动生成一个prototype属性指向其原型，同时在prototype下生成一个constructor属性指向自身。如果是实例化一个对象，则会生成一个__proto__属性指向对象的原型。当要访问一个对象的属性和方法时，如果在当前对象找不到，JavaScript引擎就会自动从它prototype、__proto__指向的原型中去寻找，知道找到或到了最顶层的Object.prototype都还未找到时才停止，未找到则返回undefined。
- 解决了什么问题：解决了JavaScript中的继承问题，使得对象之间可以共享属性和方法，同时对象之间能够实现继承关系。
- 优点：
  - 实现了属性和方法的共享：通过原型链，可以在不同对象之间共享属性和方法，节省内存
  - 实现了对象之间的继承关系：子对象可以继承付对象的属性和方法，实现了代码的复用
- 缺点：
  - 原型链过长可能会影响性能，调用某个属性或方法时，JavaScript引擎会沿原型链逐层查找，直到找到或到顶为止，可能会影响性能。
  - 无法实现私有属性和方法：所有挂在原型下的属性和方法都是共享的，无法实现真正意义上的私有属性和方法
- 改进缺点：
  - 使用组合继承，结合原型链继承和构造函数的优点，减少原型链过长的问题
  - 使用ES6提供的class语法糖，可以更清晰的定义对象之间的继承关系，同时解决一些原型链继承的问题，如无法实现私有属性和方法的问题

**原型链继承**：通过将方法添加到构造函数上，实现多对象、子类父类共享方法
**借用构造函数继承**：通过在子类构造函数中调用父类构造函数，从而在子类中插入父类的所有属性，避免了共享引用和原型链检索耗时过长的问题

### ES6的class语法糖

```JavaScript
class Person {
  #name; // 声明私有属性
  #psw = '123456';
  constructor (name) { // 构造函数
    this.#name = name;
  }
  #getName () {
    return this.#name
  }
  getName (psw) {
    return psw === this.#psw ? this.#name : 'wrong password'
  }
}
var person1 = new Person('xiaoming')
person1.#name
person1.#getName()
person1.getName('123')
person1.getName('123456')
```


### 原型模式

```JavaScript
function Person (name, sex) {
  this.name = name
  this.sex = sex
}
// 将共享方法挂在原型下
Person.prototype.changeName = function (name) {
  this.name = name
}
function Child (name, sex, age) {
  // 继承上游原型的属性和方法
  Person.call(this, name, sex)
  this.age = age
}
// 构建原型链
Child.prototype = Object.create(Person.prototype)
// 不能用 Child.prototype = new Object(Person.prototype)
Child.prototype.constructor = Child

var child1 = new Child('xiaoming', 'male', 12)
console.log(child1)
child1.changeName('xiaohua')
console.log(child1)
```

不能用 Child.prototype = new Object(Person.prototype) 代替 Child.prototype = Object.create(Person.prototype)
Object.create(...) 的第一个参数是原型，创建后的新对象原型会指向接收到的参数对象
new Object(...) 创建的新对象原型指向Object.prototype
前者是用Person.prototype的原型创建一个对象，内容为空；后者是用Object.prototype的原型创建一个对象，并赋值为Person.prototype

### 工厂模式

通过工厂函数创建对象，工厂函数就是一个普通函数，用来封装对象创建过程，对象在其内部创建并返回。用工厂模式创建的每个对象实例都是独立的，无法共享属性和方法，不共享原型

```JavaScript
function Person(name, sex) {
  var obj = {
    name,
    sex,
    changeName: function (name) { obj.name = name }
  }
  return obj
}
var person1 = new Person('xiaoming', 'male')
console.log(person1)
person1.changeName('xiaohua')
console.log(person1)
```





任何一个JS对象中创建时都会关联一个对象，任何根据原型的构造函数创建出来的对象，都会继承原型上的属性
